// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package repomocks

import (
	"github.com/andreas-kokkalis/dock_server/pkg/api"
	"sync"
)

var (
	lockRedisRepositoryMockAdminRunConfigDelete  sync.RWMutex
	lockRedisRepositoryMockAdminRunConfigExists  sync.RWMutex
	lockRedisRepositoryMockAdminRunConfigGet     sync.RWMutex
	lockRedisRepositoryMockAdminRunConfigSet     sync.RWMutex
	lockRedisRepositoryMockAdminSessionDelete    sync.RWMutex
	lockRedisRepositoryMockAdminSessionExists    sync.RWMutex
	lockRedisRepositoryMockAdminSessionKeyCreate sync.RWMutex
	lockRedisRepositoryMockAdminSessionSet       sync.RWMutex
	lockRedisRepositoryMockDeleteStaleMappedPort sync.RWMutex
	lockRedisRepositoryMockPortIsMapped          sync.RWMutex
	lockRedisRepositoryMockStripSessionKeyPrefix sync.RWMutex
	lockRedisRepositoryMockUserRunConfigDelete   sync.RWMutex
	lockRedisRepositoryMockUserRunConfigExists   sync.RWMutex
	lockRedisRepositoryMockUserRunConfigGet      sync.RWMutex
	lockRedisRepositoryMockUserRunConfigSet      sync.RWMutex
	lockRedisRepositoryMockUserRunKeyGet         sync.RWMutex
)

// RedisRepositoryMock is a mock implementation of RedisRepository.
//
//     func TestSomethingThatUsesRedisRepository(t *testing.T) {
//
//         // make and configure a mocked RedisRepository
//         mockedRedisRepository := &RedisRepositoryMock{
//             AdminRunConfigDeleteFunc: func(key string) error {
// 	               panic("TODO: mock out the AdminRunConfigDelete method")
//             },
//             AdminRunConfigExistsFunc: func(key string) (bool, error) {
// 	               panic("TODO: mock out the AdminRunConfigExists method")
//             },
//             AdminRunConfigGetFunc: func(key string) (api.RunConfig, error) {
// 	               panic("TODO: mock out the AdminRunConfigGet method")
//             },
//             AdminRunConfigSetFunc: func(key string, runConfig api.RunConfig) error {
// 	               panic("TODO: mock out the AdminRunConfigSet method")
//             },
//             AdminSessionDeleteFunc: func(key string) error {
// 	               panic("TODO: mock out the AdminSessionDelete method")
//             },
//             AdminSessionExistsFunc: func(key string) (bool, error) {
// 	               panic("TODO: mock out the AdminSessionExists method")
//             },
//             AdminSessionKeyCreateFunc: func(adminID int) string {
// 	               panic("TODO: mock out the AdminSessionKeyCreate method")
//             },
//             AdminSessionSetFunc: func(key string) error {
// 	               panic("TODO: mock out the AdminSessionSet method")
//             },
//             DeleteStaleMappedPortFunc: func(port string)  {
// 	               panic("TODO: mock out the DeleteStaleMappedPort method")
//             },
//             PortIsMappedFunc: func(port string) bool {
// 	               panic("TODO: mock out the PortIsMapped method")
//             },
//             StripSessionKeyPrefixFunc: func(key string) string {
// 	               panic("TODO: mock out the StripSessionKeyPrefix method")
//             },
//             UserRunConfigDeleteFunc: func(userID string) error {
// 	               panic("TODO: mock out the UserRunConfigDelete method")
//             },
//             UserRunConfigExistsFunc: func(userID string) (bool, error) {
// 	               panic("TODO: mock out the UserRunConfigExists method")
//             },
//             UserRunConfigGetFunc: func(userID string) (api.RunConfig, error) {
// 	               panic("TODO: mock out the UserRunConfigGet method")
//             },
//             UserRunConfigSetFunc: func(userID string, runConfig api.RunConfig) error {
// 	               panic("TODO: mock out the UserRunConfigSet method")
//             },
//             UserRunKeyGetFunc: func(userID string) string {
// 	               panic("TODO: mock out the UserRunKeyGet method")
//             },
//         }
//
//         // TODO: use mockedRedisRepository in code that requires RedisRepository
//         //       and then make assertions.
//
//     }
type RedisRepositoryMock struct {
	// AdminRunConfigDeleteFunc mocks the AdminRunConfigDelete method.
	AdminRunConfigDeleteFunc func(key string) error

	// AdminRunConfigExistsFunc mocks the AdminRunConfigExists method.
	AdminRunConfigExistsFunc func(key string) (bool, error)

	// AdminRunConfigGetFunc mocks the AdminRunConfigGet method.
	AdminRunConfigGetFunc func(key string) (api.RunConfig, error)

	// AdminRunConfigSetFunc mocks the AdminRunConfigSet method.
	AdminRunConfigSetFunc func(key string, runConfig api.RunConfig) error

	// AdminSessionDeleteFunc mocks the AdminSessionDelete method.
	AdminSessionDeleteFunc func(key string) error

	// AdminSessionExistsFunc mocks the AdminSessionExists method.
	AdminSessionExistsFunc func(key string) (bool, error)

	// AdminSessionKeyCreateFunc mocks the AdminSessionKeyCreate method.
	AdminSessionKeyCreateFunc func(adminID int) string

	// AdminSessionSetFunc mocks the AdminSessionSet method.
	AdminSessionSetFunc func(key string) error

	// DeleteStaleMappedPortFunc mocks the DeleteStaleMappedPort method.
	DeleteStaleMappedPortFunc func(port string)

	// PortIsMappedFunc mocks the PortIsMapped method.
	PortIsMappedFunc func(port string) bool

	// StripSessionKeyPrefixFunc mocks the StripSessionKeyPrefix method.
	StripSessionKeyPrefixFunc func(key string) string

	// UserRunConfigDeleteFunc mocks the UserRunConfigDelete method.
	UserRunConfigDeleteFunc func(userID string) error

	// UserRunConfigExistsFunc mocks the UserRunConfigExists method.
	UserRunConfigExistsFunc func(userID string) (bool, error)

	// UserRunConfigGetFunc mocks the UserRunConfigGet method.
	UserRunConfigGetFunc func(userID string) (api.RunConfig, error)

	// UserRunConfigSetFunc mocks the UserRunConfigSet method.
	UserRunConfigSetFunc func(userID string, runConfig api.RunConfig) error

	// UserRunKeyGetFunc mocks the UserRunKeyGet method.
	UserRunKeyGetFunc func(userID string) string

	// calls tracks calls to the methods.
	calls struct {
		// AdminRunConfigDelete holds details about calls to the AdminRunConfigDelete method.
		AdminRunConfigDelete []struct {
			// Key is the key argument value.
			Key string
		}
		// AdminRunConfigExists holds details about calls to the AdminRunConfigExists method.
		AdminRunConfigExists []struct {
			// Key is the key argument value.
			Key string
		}
		// AdminRunConfigGet holds details about calls to the AdminRunConfigGet method.
		AdminRunConfigGet []struct {
			// Key is the key argument value.
			Key string
		}
		// AdminRunConfigSet holds details about calls to the AdminRunConfigSet method.
		AdminRunConfigSet []struct {
			// Key is the key argument value.
			Key string
			// RunConfig is the runConfig argument value.
			RunConfig api.RunConfig
		}
		// AdminSessionDelete holds details about calls to the AdminSessionDelete method.
		AdminSessionDelete []struct {
			// Key is the key argument value.
			Key string
		}
		// AdminSessionExists holds details about calls to the AdminSessionExists method.
		AdminSessionExists []struct {
			// Key is the key argument value.
			Key string
		}
		// AdminSessionKeyCreate holds details about calls to the AdminSessionKeyCreate method.
		AdminSessionKeyCreate []struct {
			// AdminID is the adminID argument value.
			AdminID int
		}
		// AdminSessionSet holds details about calls to the AdminSessionSet method.
		AdminSessionSet []struct {
			// Key is the key argument value.
			Key string
		}
		// DeleteStaleMappedPort holds details about calls to the DeleteStaleMappedPort method.
		DeleteStaleMappedPort []struct {
			// Port is the port argument value.
			Port string
		}
		// PortIsMapped holds details about calls to the PortIsMapped method.
		PortIsMapped []struct {
			// Port is the port argument value.
			Port string
		}
		// StripSessionKeyPrefix holds details about calls to the StripSessionKeyPrefix method.
		StripSessionKeyPrefix []struct {
			// Key is the key argument value.
			Key string
		}
		// UserRunConfigDelete holds details about calls to the UserRunConfigDelete method.
		UserRunConfigDelete []struct {
			// UserID is the userID argument value.
			UserID string
		}
		// UserRunConfigExists holds details about calls to the UserRunConfigExists method.
		UserRunConfigExists []struct {
			// UserID is the userID argument value.
			UserID string
		}
		// UserRunConfigGet holds details about calls to the UserRunConfigGet method.
		UserRunConfigGet []struct {
			// UserID is the userID argument value.
			UserID string
		}
		// UserRunConfigSet holds details about calls to the UserRunConfigSet method.
		UserRunConfigSet []struct {
			// UserID is the userID argument value.
			UserID string
			// RunConfig is the runConfig argument value.
			RunConfig api.RunConfig
		}
		// UserRunKeyGet holds details about calls to the UserRunKeyGet method.
		UserRunKeyGet []struct {
			// UserID is the userID argument value.
			UserID string
		}
	}
}

// AdminRunConfigDelete calls AdminRunConfigDeleteFunc.
func (mock *RedisRepositoryMock) AdminRunConfigDelete(key string) error {
	if mock.AdminRunConfigDeleteFunc == nil {
		panic("moq: RedisRepositoryMock.AdminRunConfigDeleteFunc is nil but RedisRepository.AdminRunConfigDelete was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockRedisRepositoryMockAdminRunConfigDelete.Lock()
	mock.calls.AdminRunConfigDelete = append(mock.calls.AdminRunConfigDelete, callInfo)
	lockRedisRepositoryMockAdminRunConfigDelete.Unlock()
	return mock.AdminRunConfigDeleteFunc(key)
}

// AdminRunConfigDeleteCalls gets all the calls that were made to AdminRunConfigDelete.
// Check the length with:
//     len(mockedRedisRepository.AdminRunConfigDeleteCalls())
func (mock *RedisRepositoryMock) AdminRunConfigDeleteCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockRedisRepositoryMockAdminRunConfigDelete.RLock()
	calls = mock.calls.AdminRunConfigDelete
	lockRedisRepositoryMockAdminRunConfigDelete.RUnlock()
	return calls
}

// AdminRunConfigExists calls AdminRunConfigExistsFunc.
func (mock *RedisRepositoryMock) AdminRunConfigExists(key string) (bool, error) {
	if mock.AdminRunConfigExistsFunc == nil {
		panic("moq: RedisRepositoryMock.AdminRunConfigExistsFunc is nil but RedisRepository.AdminRunConfigExists was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockRedisRepositoryMockAdminRunConfigExists.Lock()
	mock.calls.AdminRunConfigExists = append(mock.calls.AdminRunConfigExists, callInfo)
	lockRedisRepositoryMockAdminRunConfigExists.Unlock()
	return mock.AdminRunConfigExistsFunc(key)
}

// AdminRunConfigExistsCalls gets all the calls that were made to AdminRunConfigExists.
// Check the length with:
//     len(mockedRedisRepository.AdminRunConfigExistsCalls())
func (mock *RedisRepositoryMock) AdminRunConfigExistsCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockRedisRepositoryMockAdminRunConfigExists.RLock()
	calls = mock.calls.AdminRunConfigExists
	lockRedisRepositoryMockAdminRunConfigExists.RUnlock()
	return calls
}

// AdminRunConfigGet calls AdminRunConfigGetFunc.
func (mock *RedisRepositoryMock) AdminRunConfigGet(key string) (api.RunConfig, error) {
	if mock.AdminRunConfigGetFunc == nil {
		panic("moq: RedisRepositoryMock.AdminRunConfigGetFunc is nil but RedisRepository.AdminRunConfigGet was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockRedisRepositoryMockAdminRunConfigGet.Lock()
	mock.calls.AdminRunConfigGet = append(mock.calls.AdminRunConfigGet, callInfo)
	lockRedisRepositoryMockAdminRunConfigGet.Unlock()
	return mock.AdminRunConfigGetFunc(key)
}

// AdminRunConfigGetCalls gets all the calls that were made to AdminRunConfigGet.
// Check the length with:
//     len(mockedRedisRepository.AdminRunConfigGetCalls())
func (mock *RedisRepositoryMock) AdminRunConfigGetCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockRedisRepositoryMockAdminRunConfigGet.RLock()
	calls = mock.calls.AdminRunConfigGet
	lockRedisRepositoryMockAdminRunConfigGet.RUnlock()
	return calls
}

// AdminRunConfigSet calls AdminRunConfigSetFunc.
func (mock *RedisRepositoryMock) AdminRunConfigSet(key string, runConfig api.RunConfig) error {
	if mock.AdminRunConfigSetFunc == nil {
		panic("moq: RedisRepositoryMock.AdminRunConfigSetFunc is nil but RedisRepository.AdminRunConfigSet was just called")
	}
	callInfo := struct {
		Key       string
		RunConfig api.RunConfig
	}{
		Key:       key,
		RunConfig: runConfig,
	}
	lockRedisRepositoryMockAdminRunConfigSet.Lock()
	mock.calls.AdminRunConfigSet = append(mock.calls.AdminRunConfigSet, callInfo)
	lockRedisRepositoryMockAdminRunConfigSet.Unlock()
	return mock.AdminRunConfigSetFunc(key, runConfig)
}

// AdminRunConfigSetCalls gets all the calls that were made to AdminRunConfigSet.
// Check the length with:
//     len(mockedRedisRepository.AdminRunConfigSetCalls())
func (mock *RedisRepositoryMock) AdminRunConfigSetCalls() []struct {
	Key       string
	RunConfig api.RunConfig
} {
	var calls []struct {
		Key       string
		RunConfig api.RunConfig
	}
	lockRedisRepositoryMockAdminRunConfigSet.RLock()
	calls = mock.calls.AdminRunConfigSet
	lockRedisRepositoryMockAdminRunConfigSet.RUnlock()
	return calls
}

// AdminSessionDelete calls AdminSessionDeleteFunc.
func (mock *RedisRepositoryMock) AdminSessionDelete(key string) error {
	if mock.AdminSessionDeleteFunc == nil {
		panic("moq: RedisRepositoryMock.AdminSessionDeleteFunc is nil but RedisRepository.AdminSessionDelete was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockRedisRepositoryMockAdminSessionDelete.Lock()
	mock.calls.AdminSessionDelete = append(mock.calls.AdminSessionDelete, callInfo)
	lockRedisRepositoryMockAdminSessionDelete.Unlock()
	return mock.AdminSessionDeleteFunc(key)
}

// AdminSessionDeleteCalls gets all the calls that were made to AdminSessionDelete.
// Check the length with:
//     len(mockedRedisRepository.AdminSessionDeleteCalls())
func (mock *RedisRepositoryMock) AdminSessionDeleteCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockRedisRepositoryMockAdminSessionDelete.RLock()
	calls = mock.calls.AdminSessionDelete
	lockRedisRepositoryMockAdminSessionDelete.RUnlock()
	return calls
}

// AdminSessionExists calls AdminSessionExistsFunc.
func (mock *RedisRepositoryMock) AdminSessionExists(key string) (bool, error) {
	if mock.AdminSessionExistsFunc == nil {
		panic("moq: RedisRepositoryMock.AdminSessionExistsFunc is nil but RedisRepository.AdminSessionExists was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockRedisRepositoryMockAdminSessionExists.Lock()
	mock.calls.AdminSessionExists = append(mock.calls.AdminSessionExists, callInfo)
	lockRedisRepositoryMockAdminSessionExists.Unlock()
	return mock.AdminSessionExistsFunc(key)
}

// AdminSessionExistsCalls gets all the calls that were made to AdminSessionExists.
// Check the length with:
//     len(mockedRedisRepository.AdminSessionExistsCalls())
func (mock *RedisRepositoryMock) AdminSessionExistsCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockRedisRepositoryMockAdminSessionExists.RLock()
	calls = mock.calls.AdminSessionExists
	lockRedisRepositoryMockAdminSessionExists.RUnlock()
	return calls
}

// AdminSessionKeyCreate calls AdminSessionKeyCreateFunc.
func (mock *RedisRepositoryMock) AdminSessionKeyCreate(adminID int) string {
	if mock.AdminSessionKeyCreateFunc == nil {
		panic("moq: RedisRepositoryMock.AdminSessionKeyCreateFunc is nil but RedisRepository.AdminSessionKeyCreate was just called")
	}
	callInfo := struct {
		AdminID int
	}{
		AdminID: adminID,
	}
	lockRedisRepositoryMockAdminSessionKeyCreate.Lock()
	mock.calls.AdminSessionKeyCreate = append(mock.calls.AdminSessionKeyCreate, callInfo)
	lockRedisRepositoryMockAdminSessionKeyCreate.Unlock()
	return mock.AdminSessionKeyCreateFunc(adminID)
}

// AdminSessionKeyCreateCalls gets all the calls that were made to AdminSessionKeyCreate.
// Check the length with:
//     len(mockedRedisRepository.AdminSessionKeyCreateCalls())
func (mock *RedisRepositoryMock) AdminSessionKeyCreateCalls() []struct {
	AdminID int
} {
	var calls []struct {
		AdminID int
	}
	lockRedisRepositoryMockAdminSessionKeyCreate.RLock()
	calls = mock.calls.AdminSessionKeyCreate
	lockRedisRepositoryMockAdminSessionKeyCreate.RUnlock()
	return calls
}

// AdminSessionSet calls AdminSessionSetFunc.
func (mock *RedisRepositoryMock) AdminSessionSet(key string) error {
	if mock.AdminSessionSetFunc == nil {
		panic("moq: RedisRepositoryMock.AdminSessionSetFunc is nil but RedisRepository.AdminSessionSet was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockRedisRepositoryMockAdminSessionSet.Lock()
	mock.calls.AdminSessionSet = append(mock.calls.AdminSessionSet, callInfo)
	lockRedisRepositoryMockAdminSessionSet.Unlock()
	return mock.AdminSessionSetFunc(key)
}

// AdminSessionSetCalls gets all the calls that were made to AdminSessionSet.
// Check the length with:
//     len(mockedRedisRepository.AdminSessionSetCalls())
func (mock *RedisRepositoryMock) AdminSessionSetCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockRedisRepositoryMockAdminSessionSet.RLock()
	calls = mock.calls.AdminSessionSet
	lockRedisRepositoryMockAdminSessionSet.RUnlock()
	return calls
}

// DeleteStaleMappedPort calls DeleteStaleMappedPortFunc.
func (mock *RedisRepositoryMock) DeleteStaleMappedPort(port string) {
	if mock.DeleteStaleMappedPortFunc == nil {
		panic("moq: RedisRepositoryMock.DeleteStaleMappedPortFunc is nil but RedisRepository.DeleteStaleMappedPort was just called")
	}
	callInfo := struct {
		Port string
	}{
		Port: port,
	}
	lockRedisRepositoryMockDeleteStaleMappedPort.Lock()
	mock.calls.DeleteStaleMappedPort = append(mock.calls.DeleteStaleMappedPort, callInfo)
	lockRedisRepositoryMockDeleteStaleMappedPort.Unlock()
	mock.DeleteStaleMappedPortFunc(port)
}

// DeleteStaleMappedPortCalls gets all the calls that were made to DeleteStaleMappedPort.
// Check the length with:
//     len(mockedRedisRepository.DeleteStaleMappedPortCalls())
func (mock *RedisRepositoryMock) DeleteStaleMappedPortCalls() []struct {
	Port string
} {
	var calls []struct {
		Port string
	}
	lockRedisRepositoryMockDeleteStaleMappedPort.RLock()
	calls = mock.calls.DeleteStaleMappedPort
	lockRedisRepositoryMockDeleteStaleMappedPort.RUnlock()
	return calls
}

// PortIsMapped calls PortIsMappedFunc.
func (mock *RedisRepositoryMock) PortIsMapped(port string) bool {
	if mock.PortIsMappedFunc == nil {
		panic("moq: RedisRepositoryMock.PortIsMappedFunc is nil but RedisRepository.PortIsMapped was just called")
	}
	callInfo := struct {
		Port string
	}{
		Port: port,
	}
	lockRedisRepositoryMockPortIsMapped.Lock()
	mock.calls.PortIsMapped = append(mock.calls.PortIsMapped, callInfo)
	lockRedisRepositoryMockPortIsMapped.Unlock()
	return mock.PortIsMappedFunc(port)
}

// PortIsMappedCalls gets all the calls that were made to PortIsMapped.
// Check the length with:
//     len(mockedRedisRepository.PortIsMappedCalls())
func (mock *RedisRepositoryMock) PortIsMappedCalls() []struct {
	Port string
} {
	var calls []struct {
		Port string
	}
	lockRedisRepositoryMockPortIsMapped.RLock()
	calls = mock.calls.PortIsMapped
	lockRedisRepositoryMockPortIsMapped.RUnlock()
	return calls
}

// StripSessionKeyPrefix calls StripSessionKeyPrefixFunc.
func (mock *RedisRepositoryMock) StripSessionKeyPrefix(key string) string {
	if mock.StripSessionKeyPrefixFunc == nil {
		panic("moq: RedisRepositoryMock.StripSessionKeyPrefixFunc is nil but RedisRepository.StripSessionKeyPrefix was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockRedisRepositoryMockStripSessionKeyPrefix.Lock()
	mock.calls.StripSessionKeyPrefix = append(mock.calls.StripSessionKeyPrefix, callInfo)
	lockRedisRepositoryMockStripSessionKeyPrefix.Unlock()
	return mock.StripSessionKeyPrefixFunc(key)
}

// StripSessionKeyPrefixCalls gets all the calls that were made to StripSessionKeyPrefix.
// Check the length with:
//     len(mockedRedisRepository.StripSessionKeyPrefixCalls())
func (mock *RedisRepositoryMock) StripSessionKeyPrefixCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockRedisRepositoryMockStripSessionKeyPrefix.RLock()
	calls = mock.calls.StripSessionKeyPrefix
	lockRedisRepositoryMockStripSessionKeyPrefix.RUnlock()
	return calls
}

// UserRunConfigDelete calls UserRunConfigDeleteFunc.
func (mock *RedisRepositoryMock) UserRunConfigDelete(userID string) error {
	if mock.UserRunConfigDeleteFunc == nil {
		panic("moq: RedisRepositoryMock.UserRunConfigDeleteFunc is nil but RedisRepository.UserRunConfigDelete was just called")
	}
	callInfo := struct {
		UserID string
	}{
		UserID: userID,
	}
	lockRedisRepositoryMockUserRunConfigDelete.Lock()
	mock.calls.UserRunConfigDelete = append(mock.calls.UserRunConfigDelete, callInfo)
	lockRedisRepositoryMockUserRunConfigDelete.Unlock()
	return mock.UserRunConfigDeleteFunc(userID)
}

// UserRunConfigDeleteCalls gets all the calls that were made to UserRunConfigDelete.
// Check the length with:
//     len(mockedRedisRepository.UserRunConfigDeleteCalls())
func (mock *RedisRepositoryMock) UserRunConfigDeleteCalls() []struct {
	UserID string
} {
	var calls []struct {
		UserID string
	}
	lockRedisRepositoryMockUserRunConfigDelete.RLock()
	calls = mock.calls.UserRunConfigDelete
	lockRedisRepositoryMockUserRunConfigDelete.RUnlock()
	return calls
}

// UserRunConfigExists calls UserRunConfigExistsFunc.
func (mock *RedisRepositoryMock) UserRunConfigExists(userID string) (bool, error) {
	if mock.UserRunConfigExistsFunc == nil {
		panic("moq: RedisRepositoryMock.UserRunConfigExistsFunc is nil but RedisRepository.UserRunConfigExists was just called")
	}
	callInfo := struct {
		UserID string
	}{
		UserID: userID,
	}
	lockRedisRepositoryMockUserRunConfigExists.Lock()
	mock.calls.UserRunConfigExists = append(mock.calls.UserRunConfigExists, callInfo)
	lockRedisRepositoryMockUserRunConfigExists.Unlock()
	return mock.UserRunConfigExistsFunc(userID)
}

// UserRunConfigExistsCalls gets all the calls that were made to UserRunConfigExists.
// Check the length with:
//     len(mockedRedisRepository.UserRunConfigExistsCalls())
func (mock *RedisRepositoryMock) UserRunConfigExistsCalls() []struct {
	UserID string
} {
	var calls []struct {
		UserID string
	}
	lockRedisRepositoryMockUserRunConfigExists.RLock()
	calls = mock.calls.UserRunConfigExists
	lockRedisRepositoryMockUserRunConfigExists.RUnlock()
	return calls
}

// UserRunConfigGet calls UserRunConfigGetFunc.
func (mock *RedisRepositoryMock) UserRunConfigGet(userID string) (api.RunConfig, error) {
	if mock.UserRunConfigGetFunc == nil {
		panic("moq: RedisRepositoryMock.UserRunConfigGetFunc is nil but RedisRepository.UserRunConfigGet was just called")
	}
	callInfo := struct {
		UserID string
	}{
		UserID: userID,
	}
	lockRedisRepositoryMockUserRunConfigGet.Lock()
	mock.calls.UserRunConfigGet = append(mock.calls.UserRunConfigGet, callInfo)
	lockRedisRepositoryMockUserRunConfigGet.Unlock()
	return mock.UserRunConfigGetFunc(userID)
}

// UserRunConfigGetCalls gets all the calls that were made to UserRunConfigGet.
// Check the length with:
//     len(mockedRedisRepository.UserRunConfigGetCalls())
func (mock *RedisRepositoryMock) UserRunConfigGetCalls() []struct {
	UserID string
} {
	var calls []struct {
		UserID string
	}
	lockRedisRepositoryMockUserRunConfigGet.RLock()
	calls = mock.calls.UserRunConfigGet
	lockRedisRepositoryMockUserRunConfigGet.RUnlock()
	return calls
}

// UserRunConfigSet calls UserRunConfigSetFunc.
func (mock *RedisRepositoryMock) UserRunConfigSet(userID string, runConfig api.RunConfig) error {
	if mock.UserRunConfigSetFunc == nil {
		panic("moq: RedisRepositoryMock.UserRunConfigSetFunc is nil but RedisRepository.UserRunConfigSet was just called")
	}
	callInfo := struct {
		UserID    string
		RunConfig api.RunConfig
	}{
		UserID:    userID,
		RunConfig: runConfig,
	}
	lockRedisRepositoryMockUserRunConfigSet.Lock()
	mock.calls.UserRunConfigSet = append(mock.calls.UserRunConfigSet, callInfo)
	lockRedisRepositoryMockUserRunConfigSet.Unlock()
	return mock.UserRunConfigSetFunc(userID, runConfig)
}

// UserRunConfigSetCalls gets all the calls that were made to UserRunConfigSet.
// Check the length with:
//     len(mockedRedisRepository.UserRunConfigSetCalls())
func (mock *RedisRepositoryMock) UserRunConfigSetCalls() []struct {
	UserID    string
	RunConfig api.RunConfig
} {
	var calls []struct {
		UserID    string
		RunConfig api.RunConfig
	}
	lockRedisRepositoryMockUserRunConfigSet.RLock()
	calls = mock.calls.UserRunConfigSet
	lockRedisRepositoryMockUserRunConfigSet.RUnlock()
	return calls
}

// UserRunKeyGet calls UserRunKeyGetFunc.
func (mock *RedisRepositoryMock) UserRunKeyGet(userID string) string {
	if mock.UserRunKeyGetFunc == nil {
		panic("moq: RedisRepositoryMock.UserRunKeyGetFunc is nil but RedisRepository.UserRunKeyGet was just called")
	}
	callInfo := struct {
		UserID string
	}{
		UserID: userID,
	}
	lockRedisRepositoryMockUserRunKeyGet.Lock()
	mock.calls.UserRunKeyGet = append(mock.calls.UserRunKeyGet, callInfo)
	lockRedisRepositoryMockUserRunKeyGet.Unlock()
	return mock.UserRunKeyGetFunc(userID)
}

// UserRunKeyGetCalls gets all the calls that were made to UserRunKeyGet.
// Check the length with:
//     len(mockedRedisRepository.UserRunKeyGetCalls())
func (mock *RedisRepositoryMock) UserRunKeyGetCalls() []struct {
	UserID string
} {
	var calls []struct {
		UserID string
	}
	lockRedisRepositoryMockUserRunKeyGet.RLock()
	calls = mock.calls.UserRunKeyGet
	lockRedisRepositoryMockUserRunKeyGet.RUnlock()
	return calls
}
